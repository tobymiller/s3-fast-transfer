package cmd

type ThreadDataFunc[TThreadData interface{}] func() (TThreadData, error)
type ThreadFunc[T interface{}, TThreadData interface{}] func(thing T, threadData TThreadData) error

func runThreads[T, TThreadData](threadFunc ThreadFunc[T, TThreadData], inputs []T, threadDataFunc ThreadDataFunc[TThreadData], threadCount int) {
	tasks := make(chan T, threadCount)

	// a channel to receive results from the test tasks back on the main thread
	results := make(chan error, len(inputs))

	// create the workers for all the threads in this test
	for w := 1; w <= threadCount; w++ {
		go func(tasks <-chan T, results chan<- error) {
			threadData, err := threadDataFunc()
			if err != nil {
				panic(err)
			}
			for task := range tasks {
				err := threadFunc(T(task), TThreadData(threadData))
				results <- err
			}
		}(tasks, results)
	}

	for i := range inputs {
		tasks <- T(i)
	}

	close(tasks)

	for i := 0; i < len(inputs); i++ {
		err := <- results
		if err != nil {
			panic(err) // for now, maybe we could retry it in future
		}
	}
}